# На прошлом занятии

Мы посмотрели: 
- базовые арифметические операции в питоне
- константы и переменные
- типы переменных (str, int и float) и способ перевести переменную из одного типа в другой
- функции `print()` и `input()`

# Условия

Все рассматриваемые нами ранее программы имели линейную структуру — программа просто выполняла инструкции одну за другой сверху вниз. При этом никаких способов повлиять на ход выполнения у нас не было (разве что только на уровне выводимых на экран параметров). Также важно то, что наши предыдущие программы обязаны были выполнить **все** инструкции сверху вниз, в противном случае они бы завершались ошибкой.

Теперь предположим, что мы хотим определить абсолютное значение любого числа. Чтобы результат был всегда неотрицателен, наша программа должна будет напечатать сам введенный `x` в случае, если он и так неотрицателен и `-x` в противном случае. Линейной структурой программы здесь не обойтись, поэтому нам на помощь приходит инструкция `if` (если). Вот как это работает в питоне:

    x = int(input())
    if x > 0:
        print(x)
    else:
        print(-x)

Разберем этот кусочек кода. После слова `if` указывается проверяемое условие `(x > 0)`, завершающееся двоеточием. После этого идет блок (последовательность) инструкций, который будет выполнен, если условие истинно, в нашем примере это вывод на экран величины `x`. Затем идет слово `else` (иначе), также завершающееся двоеточием, и блок инструкций, который будет выполнен, если проверяемое условие неверно, в данном случае будет выведено значение `-x`.

Обратите особенное внимание на отступы во фрагменте кода выше. Дело в том, что в питоне, для того, чтобы определить, какой именно код выполнить в результате того или иного условия используется как знак двоеточия (в строке с самим условием), так и отступы от левого края строки.

Все инструкции, которые относятся к одному блоку, должны иметь равную величину отступа, то есть одинаковое число пробелов в начале строки. Рекомендуется использовать отступ в 4 пробела или знак табуляции (клавишу Tab или клавишу ⇥ на маках).

Во многих других языках вместо отступов используются конструкции, явно указывающие на начало (begin или открывающаяся фигурная скобка в Си) и конец инструкций, связанных с условием (end или закрывающаяся фигурная скобка в Си). Отступы же выполняют примерно ту же роль, но и заодно делают код более читаемым, позволяя читающему быстро понять, какой именно код относится к условию.

Таким образом, условные конструкции в питоне имеют следующий общий вид:

    if Условие:
        блок инструкций, в случае если условие истинно
    else:
        блок инструкций, в случае если условие не выполняется

Вторая часть условной конструкции (та, что с `else`) может и отсутствовать, например так:

     x = int(input())
     if x < 0:
         x = -x
     print(x)

Эта программа тоже выведет абсолютное значение x, как и та, что была ранее.

# Операторы сравнения

Все операторы сравнения в питоне достаточно интуитивны. Вот список основных:    
`>` - больше. Условие истинно, если то, что слева от знака больше того, что справа.       
`<` - меньше. Условие истинно, если то, что слева от знака меньше того, что справа.    
`>=` - больше либо равно.    
`<=` - меньше либо равно.    
`==` - в точности равно.   
`!=` - не равно.    

# Вложенные условные инструкции

Условия могут быть вложены одно в другое, чтобы реализовывать еще более сложную логику, например:

    a = int(input())
    b = int(input())
    if a > 0:
        if b > 0:
            print("a, b > 0")
        else:
            print("a > 0, b < 0")
    else:
        if b > 0:
            print("a, b < 0")
        else:
            print("a < 0, b > 0")

# Тип данных `bool`

Операторы сравнения возвращают значения специального логического типа `bool`. Значения логического типа могут принимать одно из двух значений: `True` (истина) или `False` (ложь). Если преобразовать логическое `True` к типу `int`, то получится `1`, а преобразование `False` даст `0`. При обратном преобразовании число `0` преобразуется в `False`, а любое ненулевое число в `True`. При преобразовании `str` в `bool` пустая строка преобразовывается в `False`, а любая непустая строка в `True`.

# Логические операторы

Если мы хотим проверить два или более условий за раз, мы можем воспользоваться операторами `and`, `or` или `not`. Вот как они работают:
- `and` (логическое И) возвращает истину (`True`) только в случае если оба условия по отдельности верны (тоже возвращают `True`)
- `or` (логическое ИЛИ) вернет истину в случае, если хотя бы одно из условий верно.
- `not` (логическое НЕТ) возьмет результат условия и "обратит" его. То есть, если результат условия `True`, то `not` примененный к этому условию вернет `False` и наоборот.

Давайте посмотрим как это работает на примере. Код ниже проверяет, что хотя бы одно число из двух нацело делится на 10 (кончается на 0) и если так, то печатает YES, а если нет, то печатает NO:

    a = int(input())
    b = int(input())
    if a % 10 == 0 or b % 10 == 0:
        print('YES')
    else:
        print('NO')

Пусть теперь мы хотим проверить, что числа a и b должны быть еще и обязательно больше нуля:

    a = int(input())
    b = int(input())
    if (a % 10 == 0 and a > 0) or (b % 10 == 0 and b > 0):
        print('YES')
    else:
        print('NO')

Как видите, мы можем не только использовать `and` и `or` в одном `if`, но и группировать условия скобками для того, чтобы явно обозначить приоритет вычисления условий.

Посмотрим пример с `not`. Пусть мы хотим проверить, что число `a` - положительное, а число `b` - неотрицательное. Это можно проверить вот таким условием:

    if a > 0 and not (b < 0):

Кстати, `not (b < 0)` можно было бы и заменить на `b >= 0` и код бы работал точно так же.

# Конструкция elif

Иногда писать конструкции `if-else` долго и утомительно, особенно если приходится проверять много условий разом. В этом случае на помощь придет `elif` (сокращение от `else if`). По сути `elif` позволяет существенно упростить конструкцию ниже:

    if a > 0:
        ...
    else:
        if b > 0:
            ...

И сделать ее вот такой:

    if a > 0:
        ...
    elif b > 0:
        ...

Обратите внимание, мы избавились от одного уровня вложенности. То есть, сам код стал более читаемым, но при этом нисколько не проиграл в функциональности. Разумеется, конструкции типа `if-elif` могут завершиться и блоком `else`, например так:

    if a > 0:
        ...
    elif b > 0:
        ...
    elif c > 0:
        ...
    else:
        ...

# Задача: знак числа

В математике есть функция, показывающая знак числа (`sign`). Она определяется так: если число больше 0, то функция возвращает 1. Если число меньше нуля, то функция возвращает -1. Если число равно 0, то функция возвращает 0. Реализуйте данную функцию - для введенного числа выведите число, определяющее его знак. Используйте операторы сравнения и конструкцию `if-elif-else`.

Возможное решение:

    x = int(input())
    if x > 0:
        print(1)
    elif x < 0:
        print(-1)
    else:
        print(0)

# Задача: високосный год

Дано натуральное число. Требуется определить, является ли год с данным номером високосным. Если год является високосным, то выведите YES, иначе выведите NO. Напомним, что в соответствии с григорианским календарем, год является високосным, если его номер кратен 4, но не кратен 100, а также если он кратен 400.

Возможное решение:

    year = int(input())
    if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):
        print("YES")
    else:
        print("NO")

# ДЗ

Варианты и правила оценивания находятся здесь: https://github.com/morgan1189/HSE-Programming/wiki/Как-выставляется-оценка-по-курсу%3F

Вам надо написать на питоне программу, которая спрашивала бы у пользователя три числа (a, b и c), а дальше, в зависимости от номера Вашего варианта, сообщала бы пользователю, обладают или не обладают введённые числа некоторыми свойствами.
Вот общий список свойств:
1. a и b в сумме дают c
2. a умножить на b равно c
3. a даёт остаток c при делении на b
4. c является решением линейного уравнения ax + b = 0
5. a разделить на b равно c
6. a в степени b равно c.

Если у Вас 1-й вариант, программа должна проверять свойства (1) и (4), 2-й -- (2) и (4), 3-й -- (3) и (4), 4-й -- (1) и (5), 5-й -- (2) и (5), 6-й -- (3) и (5), 7-й -- (5) и (6). То есть если у Вас, например, 4-й вариант, то Ваша программа должна проверять, дают ли a и b в сумме число c и получится ли c, если a разделить на b, и сообщать об этом.

# Ссылки по теме:
http://pythontutor.ru/lessons/ifelse/    
http://pythonicway.com/python-conditionals - чуть больше примеров использования if
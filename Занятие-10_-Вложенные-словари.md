# На прошлом занятии
* создание и изменение словарей
* перебор словарей
* пример: частотный словарь

# План этого занятия
* пример вложенной структуры: словарь словарей словарей списков строк

# Пример вложенной структуры

Будем работать с уникальным набором данных: набором всех реплик персонажей сериала «South Park» за первые 18 сезонов. Для работы понадобится файл [all-seasons.csv](https://github.com/walkerkq/textmining_southpark/blob/master/data/raw%20data/all-seasons.csv)

Для решения целого ряда прикладных задач с данными будет удобно создать словарь `d`, который будет содержать в качестве ключей номер сезона, а в качестве элементов — словари, которые, в свою очередь, будут содержать в качестве ключа номер эпизода, а в качестве элемента — словари, содержащие в качестве ключа имя персонажа, а качестве значения список его реплик, произнесенных в данном эпизоде. Звучит сложно, но давайте представим как будет выглядеть такой словарь `d`:
```python
d = {
    'сезон1': {
        'эпизод1': {
            'персонаж1': [
                'реплика1',
                'реплика2',
                'реплика3',
            ],
            'персонаж2': [
                'реплика1',
                'реплика2',
                'реплика3',
            ],
        },
        'эпизод2': {
            'персонаж1': [
                'реплика1',
            ],
        },
    },
    'сезон2': {
        'эпизод1': {
            'персонаж1': [
                'реплика1',
                'реплика2',
                'реплика3',
            ],
        },
        'эпизод2': {
            'персонаж1': [
                'реплика1',
                'реплика2',
            ],
            'персонаж2': [
                'реплика1',
                'реплика2',
                'реплика3',
            ],

        },
    },
}
```

Забегая вперед отметим, что для того, что бы получить первую реплику Кайла в первом эпизоде пятого сезона нужно будет просто обратиться к элементу `d['5']['1']['Kyle'][0]`. Здесь номера сезона и эпизода в кавычках просто для простаты написания кода, можно было сделать и более аккуратно.

Вот пример кода, который создает такой сложный словарь из нашего файла:
```python
def get_south_park_dict(filename):
    d = {}
    with open(filename, encoding='utf-8') as f:
        quote = ''
        for line in f:
            if line == 'Season,Episode,Character,Line\n':
                continue
            if quote == '':
                # Именно здесь у нас переменные season и episode задаются.
                # Видно, что они являются строковыми переменными, хотя,
                # конечно, это можно легко изменить, но делать это мы не будем
                season, episode, char, quote = line.split(',', maxsplit=3)
            else:
                quote += line
            if line == '"\n':
                season_dict = d.setdefault(season, {})
                episode_dict = season_dict.setdefault(episode, {})
                quote_list = episode_dict.setdefault(char, [])
                quote_list.append(quote)
                quote = ''
    return d
```

## Примеры задач, для которых удобна такая вложенная структура

### Отсортированный список персонажей, разговаривавших в эпизоде
```python
def get_characters(d, season, episode):
    """Возвращает список персонажей эпизода, отсортированный в алфавитном порядке"""
    # Ключи d[season] - эпизоды, а ключи d[season][episode] - персонажи
    return sorted(d[season][episode])
```

### Какой сезон самый длинный?
```python
def get_the_longest_season(d):
    """Имя самого длинного сезона. Если их несколько, то может быть возвращен любой из них"""
    max_len = 0
    for k, v in d:  # k - название сезона, v - словарь с ключами-эпизодами
       if len(v) > max_len:
           max_len = len(v)
           season = k
    return season
```

### Кто произнес больше всего фраз в данном эпизоде?
```python
# Будем использовать collections.Counter и вспомогательную функцию, которая вернет несколько
# самых болтливых персонажей
def chatterboxes(d, season, episode, top_n):
    """Список пар персонаж-количество реплик, уопрядоченных по убыванию числа реклик,
    не более top_n штук
    """
    counter = collections.Counter()
    for k, v in d[season][episode].items():
        counter[k] = len(v)
    return counter.most_common(top_n)

def chatterbox(d, season, episode):
    """Самый болтливый персонаж эпизода, если таких несколько, будет возвращен только один из них"""
    return chatterboxes(d, season, episode, 1)[0][0]
```

### В каких эпизодах слово/словосочетание употреблялось заданное число раз
```python
def episodes_with_word(d, word, at_most):
    """Список эпизодов в формате 'сезон.эпизод', в которых word встретился по
    крайней мере at_most раз
    """
    episodes = []
    word = word.lower()
    for season, season_dict in d.items():
        for episode, episode_dict in season_dict.items():
            n = 0
            for char, quote_list in episode_dict.items():
                for quote in quote_list:
                    n += quote.lower().count(word)
            if n >= at_most:
                episodes.append(str(season)+'.'+str(episode))
    return episodes
```

# Домашнее задание
**Дедлайн: 18 февраля 23:59**

Вам нужно написать программу, которая загадывает слова. Загадав существительное, программа показывает подсказку в виде распространённого словосочетания с этим существительным, в котором существительное заменено многоточием, и ждёт ответа пользователя, после чего сообщает, выиграл он или проиграл. Например, если загадано слово «снег», можно показать подсказку «белый ...». Словосочетание можно подсмотреть в [корпусе](http://ruscorpora.ru/beta/search-ngrams_2.html) или довериться интуиции.

В задании обязательно использовать словарь. Программа должна уметь загадывать как минимум 5 разных слов (с разными подсказками). Кроме того, желательно, чтобы слова и подсказки хранились в отдельном csv-файле, который загружался бы при запуске программы.

Дополнительные свойства программы по вариантам: 

1. Пользователю даётся столько попыток угадать слово, сколько букв в слове;
2. Многоточие должно содержать столько точек, сколько букв в слове;
3. Пользователю даётся столько попыток угадать слово, сколько букв в подсказке;
4. Многоточие должно содержать столько точек, сколько букв в подсказке;
5. Программа показывает число попыток, которое пользователь уже сделал, чтобы угадать слово;
6. Программа показывает число попыток, которое осталось пользователю до лимита в 3 попытки;
7. Программа сообщает пользователю о том, что он выиграл или проиграл, разными случайными формулировками.

С csv-файлами можно работать так же, как и с обычными файлами. Если данные в вашем файле разделены при помощи запятых, то:
* открываете файл
* читаете его по строкам
* каждую строку делите по запятым при помощи .split(',')
* получаете массив с данными, содержащимися в конкретной строке.
* делаете с ними что хотите